/* eslint-disable @typescript-eslint/no-unsafe-argument */
import { Test, TestingModule } from '@nestjs/testing'
import { INestApplication, ValidationPipe, ServiceUnavailableException } from '@nestjs/common'
import request from 'supertest'
import { AppModule } from './../src/app.module'
import { PrismaService } from '../src/prisma/prisma.service'
import { S3Service } from '../src/s3/s3.service'
import { QueueService } from '../src/queue/queue.service'
import { MalwareScannerService } from '../src/documents/malware-scanner.service'

// Local enum mirror for Prisma Status (string union)
const Status = {
  UPLOADED: 'UPLOADED',
  QUEUED: 'QUEUED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const

interface LoginResponse {
  accessToken: string
  user: { id: string; email: string }
}

interface SubjectResponse {
  id: string
  name: string
  createdAt: string
  updatedAt: string
}

// Standard EICAR test signature string
function makeEicarBuffer(): Buffer {
  const eicar =
    'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
  return Buffer.from(eicar, 'utf-8')
}

// This suite requires a live clamd reachable at CLAMAV_HOST:CLAMAV_PORT
// The CI job provides the service and sets CLAMAV_ENABLED=true.
describe('Malware (clamd integration) (e2e)', () => {
  let app: INestApplication
  let prisma: PrismaService
  let s3Mock: { putObject: jest.Mock }
  let queueMock: { publishDocumentJob: jest.Mock }

  beforeAll(() => {
    // Ensure scanner is enabled even in test env
    process.env.CLAMAV_ENABLED = 'true'
    // Host/port are provided by CI; default to localhost:3310 for local runs
    if (!process.env.CLAMAV_HOST) process.env.CLAMAV_HOST = '127.0.0.1'
    if (!process.env.CLAMAV_PORT) process.env.CLAMAV_PORT = '3310'
    // Explicitly do not skip scan
    process.env.SKIP_MALWARE_SCAN = 'false'
  })

  beforeEach(async () => {
    s3Mock = { putObject: jest.fn().mockResolvedValue(undefined) }
    queueMock = { publishDocumentJob: jest.fn(() => undefined) }

    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    })
      .overrideProvider(S3Service)
      .useValue(s3Mock)
      .overrideProvider(QueueService)
      .useValue(queueMock)
      .compile()

    app = moduleFixture.createNestApplication()
    prisma = moduleFixture.get<PrismaService>(PrismaService)

    await prisma.document.deleteMany()
    await prisma.subject.deleteMany()
    await prisma.user.deleteMany()

    app.useGlobalPipes(
      new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true, transform: true })
    )
    await app.init()
  })

  afterEach(async () => {
    await prisma.$disconnect()
    await app.close()
  })

  it('EICAR-infected upload returns 400, marks document FAILED, and does not call S3/Queue', async () => {
    // Quick probe: if clamd is truly unavailable, skip the test to avoid CI flakes
    const scanner = app.get(MalwareScannerService)
    try {
      await scanner.scan(Buffer.from('hello'), 'probe.txt')
    } catch (e) {
      if (e instanceof ServiceUnavailableException) {
        console.warn('[E2E] ClamAV unavailable; skipping EICAR test')
        return
      }
      throw e
    }

    const token = await signup('clamav_e2e@test.com')
    const subjectId = await createSubject(token, 'Security')

    const eicar = makeEicarBuffer()

    const res = await request(app.getHttpServer())
      .post(`/subjects/${subjectId}/documents`)
      .set('Authorization', `Bearer ${token}`)
      .attach('file', eicar, 'eicar.txt')

    expect(res.status).toBe(400)

    const doc = await prisma.document.findFirst({ where: { subjectId }, orderBy: { createdAt: 'desc' } })
    expect(doc).toBeTruthy()
    expect(doc?.status).toBe(Status.FAILED)
    expect(s3Mock.putObject).not.toHaveBeenCalled()
    expect(queueMock.publishDocumentJob).not.toHaveBeenCalled()
  })

  const signup = async (email: string, password = 'password123') => {
    const res = await request(app.getHttpServer())
      .post('/auth/signup')
      .send({ email, password })
      .expect(201)
    return (res.body as LoginResponse).accessToken
  }

  const createSubject = async (token: string, name: string) => {
    const res = await request(app.getHttpServer())
      .post('/subjects')
      .set('Authorization', `Bearer ${token}`)
      .send({ name })
      .expect(201)
    return (res.body as SubjectResponse).id
  }
})
