import { Injectable, ServiceUnavailableException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import ClamScanLib from 'clamscan';

export interface MalwareScanResult {
  clean: boolean;
  reason?: string;
}

// AppConfig type alias removed (unused)

type ClamInitOptions = {
  removeInfected: boolean;
  quarantineInfected: boolean;
  debugMode: boolean;
  clamscan: { active: boolean };
  clamdscan: {
    active: boolean;
    host: string;
    port: number;
    timeout: number; // seconds
    localFallback: boolean;
  };
};

type ClamClient = {
  scanBuffer: (buffer: Buffer) => Promise<
    | boolean
    | string
    | {
        isInfected?: boolean;
        viruses?: string[];
      }
  >;
};

type ClamScanCtor = new () => {
  init: (options: ClamInitOptions) => Promise<ClamClient>;
};

@Injectable()
export class MalwareScannerService {
  private cl: ClamClient | undefined;
  private initializing?: Promise<void>;
  private readonly skipScan = process.env.SKIP_MALWARE_SCAN === 'true';

  constructor(private readonly config: ConfigService) {}

  private async ensureClient() {
    if (this.cl) return;
    if (this.initializing) {
      await this.initializing;
      return;
    }

    // Lazy-init clamd client via clamscan
    this.initializing = (async () => {
      const ClamScan = ClamScanLib as unknown as ClamScanCtor;
      const cfg = this.config.get<{
        enabled: boolean;
        host: string;
        port: number;
        connectTimeoutMs: number;
        readTimeoutMs: number;
      }>('app.clamav');
      if (!cfg) {
        if (this.skipScan) {
          // Skip scanner initialization entirely in dev
          return;
        }
        throw new ServiceUnavailableException('Malware scanner is unavailable');
      }
      try {
        const nc = new ClamScan();
        this.cl = await nc.init({
          removeInfected: false,
          quarantineInfected: false,
          debugMode: false,
          clamscan: { active: false },
          clamdscan: {
            active: true,
            host: cfg.host,
            port: cfg.port,
            timeout: Math.ceil((cfg.readTimeoutMs || 10000) / 1000),
            localFallback: false,
          },
        } as ClamInitOptions);
      } catch {
        if (this.skipScan) {
          // In dev, treat scanner init failure as a noop
          this.cl = undefined;
          return;
        }
        throw new ServiceUnavailableException('Malware scanner is unavailable');
      }
    })();

    await this.initializing;
  }

  async scan(buffer: Buffer): Promise<MalwareScanResult> {
    if (this.skipScan) {
      // Dev bypass: always clean
      return { clean: true };
    }
    const cfg = this.config.get<{
      enabled: boolean;
      host: string;
      port: number;
      connectTimeoutMs: number;
      readTimeoutMs: number;
    }>('app.clamav');
    if (!cfg) {
      if (this.skipScan) return { clean: true };
      throw new ServiceUnavailableException('Malware scanner is unavailable');
    }

    if (!cfg.enabled) {
      // Explicitly disabled (e.g., certain E2E runs)
      return { clean: true };
    }

    await this.ensureClient();

    try {
      const res = await this.cl!.scanBuffer(buffer);
      const isInfected =
        (typeof res === 'object' &&
          'isInfected' in res &&
          Boolean((res as { isInfected?: boolean }).isInfected)) ||
        (typeof res === 'boolean' && res === true) ||
        (typeof res === 'string' && res.toUpperCase().includes('FOUND'));

      if (isInfected) {
        let reason: string | undefined;
        if (
          typeof res === 'object' &&
          Array.isArray((res as { viruses?: string[] }).viruses)
        ) {
          reason = ((res as { viruses?: string[] }).viruses || []).join(', ');
        }
        return { clean: false, reason: reason || 'infected' };
      }
      return { clean: true };
    } catch {
      // Fail-closed on scanner failures/timeouts/connectivity
      if (this.skipScan) return { clean: true };
      throw new ServiceUnavailableException('Malware scanner is unavailable');
    }
  }
}
